/*=========================================================================
Program:   ALBA
Module:    albaOpExporterAbaqusFile.cpp
Language:  C++
Date:      $Date: 2009-05-19 14:29:53 $
Version:   $Revision: 1.1 $
Authors:   Nicola Vanella
==========================================================================
Copyright (c) BIC-IOR 2019 (https://github.com/IOR-BIC)

This software is distributed WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. See the above copyright notice for more information.
=========================================================================*/

#include "albaDefines.h" 
//----------------------------------------------------------------------------
// NOTE: Every CPP file in the ALBA must include "albaDefines.h" as first.
// This force to include Window,wxWidgets and VTK exactly in this order.
// Failing in doing this will result in a run-time error saying:
// "Failure#0: The value of ESP was not properly saved across a function call"
//----------------------------------------------------------------------------

#include "albaDecl.h"

#include "albaOpExporterAbaqusFile.h"

#include "wx/stdpaths.h"

#include "albaDecl.h"
#include "albaGUI.h"
#include "albaSmartPointer.h"
#include "albaVME.h"
#include "albaVMEMesh.h"
#include "albaVMEMeshAnsysTextExporter.h"
#include "albaAbsMatrixPipe.h"
#include "albaProgressBarHelper.h"

#include <iostream>
#include <fstream>

// vtk includes
#include "vtkALBASmartPointer.h"
#include "vtkUnstructuredGrid.h"
#include "vtkCellArray.h"
#include "vtkDoubleArray.h"
#include "vtkIntArray.h"
#include "vtkPointData.h"
#include "vtkCellData.h"
#include "vtkFieldData.h"
#include "vtkTransform.h"
#include "vtkTransformFilter.h"

// vcl includes
#include <vcl_string.h>
#include <vcl_fstream.h>
#include <vcl_sstream.h>
#include <vcl_map.h>
#include <vcl_vector.h>

//----------------------------------------------------------------------------
albaCxxTypeMacro(albaOpExporterAbaqusFile);
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
albaOpExporterAbaqusFile::albaOpExporterAbaqusFile(const wxString &label) :
	albaOpExporterFEMCommon(label)
{
	m_OpType = OPTYPE_EXPORTER;
	m_Canundo = true;

  m_ImportedVmeMesh = NULL;
	m_AbaqusOutputFileNameFullPath		= "";
}
//----------------------------------------------------------------------------
albaOpExporterAbaqusFile::~albaOpExporterAbaqusFile()
{
  for(int i=0; i< m_Elsets.size();i++)
  {
    for (int j=0; j<m_Elsets[i].elementsIDVect.size(); j++)
    {
      m_Elsets[i].elementsIDVect.clear();
    }
  }

  m_Elsets.clear();
  m_MatIDMap.clear();

  albaDEL(m_ImportedVmeMesh);
}

//----------------------------------------------------------------------------
albaOp* albaOpExporterAbaqusFile::Copy()   
{
  albaOpExporterAbaqusFile *cp = new albaOpExporterAbaqusFile(m_Label);
  return cp;
}

//----------------------------------------------------------------------------
albaString albaOpExporterAbaqusFile::GetWildcard()
{
  return "inp files (*.inp)|*.inp|All Files (*.*)|*.*";
}

//----------------------------------------------------------------------------
void albaOpExporterAbaqusFile::OnOK()
{
  albaString wildcard = GetWildcard();

  m_AbaqusOutputFileNameFullPath = "";

  wxString f;
  f = albaGetSaveFile("",wildcard).ToAscii(); 
  if(!f.IsEmpty())
  {
    m_AbaqusOutputFileNameFullPath = f;
    Write();
  }
}
//----------------------------------------------------------------------------
void albaOpExporterAbaqusFile::OpStop(int result)
{
  HideGui();
  albaEventMacro(albaEvent(this,result));        
}

//----------------------------------------------------------------------------
int albaOpExporterAbaqusFile::compareElem(const void *p1, const void *p2) 
{
  ExportElement *a, *b;
  a = (ExportElement *)p1;
  b = (ExportElement *)p2;

  double result;

  result = a->elementType - b->elementType;  
  if (result < 0)
    return -1;
  else if (result > 0)
    return 1;
  else
  {
    result = a->matID - b->matID;  
    if (result < 0)
      return -1;
    else if (result > 0)
      return 1;
    else
      return 0;
  }
}


//---------------------------------------------------------------------------
int albaOpExporterAbaqusFile::Write()
{
  FILE *outFile;
  outFile = fopen(m_AbaqusOutputFileNameFullPath.ToAscii(), "w");

  albaVMEMesh *input = albaVMEMesh::SafeDownCast(m_Input);

  input->Update();
  input->GetUnstructuredGridOutput()->Update();
  input->GetUnstructuredGridOutput()->GetVTKData()->Update();

  // Init ProgressBar
  m_ProgressHelper = new albaProgressBarHelper(m_Listener);
  m_ProgressHelper->SetTextMode(m_TestMode);
  m_ProgressHelper->InitProgressBar("Please wait exporting file...");


  // *Heading
  //  ** Job name: test Model name: test
  //  ** Generated by: py_bonemat_abaqus
  // *Preprint, echo=NO, model=NO, history=NO, contact=NO

  WriteHeaderFile(outFile);

  fprintf(outFile,"**\n");

  // *Node
  //    1,         -1.0,          1.0,         -1.0    
  WriteNodesFile(outFile);


  //*Element, type=C3D10
  //    1,      1,      2,      3,      4,      5,      6,      7,      8,      9,     10
  WriteElementsFile(outFile);
  
  fprintf(outFile,"**\n");

  // Materials
  
  //*Material, name=Mat_1
  //*Elastic
  //6.759396380901535, 0.35
  
  WriteMaterialsFile(outFile);
	
  fclose(outFile);

  cppDEL(m_ProgressHelper);

  return ALBA_OK;
}

//---------------------------------------------------------------------------
int albaOpExporterAbaqusFile::WriteHeaderFile(FILE *file)
{
  wxString jobName="";
  wxString modelName="";

  wxString header = "*Heading\n** Job name: " + jobName + " Model name: " + modelName + "\n";
  header += "** Generated by: Bonemat\n";
  header += "*Preprint, echo=NO, model=NO, history=NO, contact=NO\n";

  fprintf(file, header); 

  return ALBA_OK;
}
//---------------------------------------------------------------------------
int albaOpExporterAbaqusFile::WriteNodesFile(FILE *file)
{
  albaVMEMesh *input = albaVMEMesh::SafeDownCast(m_Input);
  assert(input);

  vtkUnstructuredGrid *inputUGrid = input->GetUnstructuredGridOutput()->GetUnstructuredGridData();

  vtkIntArray *nodesIDArray = input->GetNodesIDArray();

  vtkIntArray *syntheticNodesIDArray = NULL;

  if (nodesIDArray == NULL)
  {
    albaLogMessage("nodesID informations not found in vtk unstructured grid!\
                  Temporary nodes id array will be created in order to export the data.");

    int numPoints = inputUGrid->GetNumberOfPoints();
    syntheticNodesIDArray = vtkIntArray::New();

    int offset = 1 ;
    for (int i = 0; i < numPoints; i++) 
    {
      syntheticNodesIDArray->InsertNextValue(i + offset);
    }

    nodesIDArray = syntheticNodesIDArray;
  }

  assert(nodesIDArray != NULL);

  // get the pointsToBeExported
  int columnsNumber;
  int rowsNumber = inputUGrid->GetNumberOfPoints();
  columnsNumber = 4; // point ID + point coordinates

  vtkPoints *pointsToBeExported = NULL;

  vtkTransform *transform = NULL;
  vtkTransformFilter *transformFilter = NULL;
  vtkUnstructuredGrid *inUGDeepCopy = NULL;

  if (m_ABSMatrixFlag)
  {
    albaVMEMesh *inMesh = albaVMEMesh::SafeDownCast(m_Input);
    assert(inMesh);

    vtkMatrix4x4 *matrix = inMesh->GetAbsMatrixPipe()->GetMatrixPointer()->GetVTKMatrix();

    // apply abs matrix to geometry
    assert(matrix);

    transform = vtkTransform::New();
    transform->SetMatrix(matrix);

    transformFilter = vtkTransformFilter::New();
    inUGDeepCopy = vtkUnstructuredGrid::New();
    inUGDeepCopy->DeepCopy(inputUGrid);

    transformFilter->SetInput(inUGDeepCopy);
    transformFilter->SetTransform(transform);
    transformFilter->Update();

    pointsToBeExported = transformFilter->GetOutput()->GetPoints();
  } 
  else
  {
    // do not transform geometry
    pointsToBeExported = inputUGrid->GetPoints();
  }

  // read all the pointsToBeExported in memory (vnl_matrix)

  int pointIDColumn = 0;
  double pointCoordinates[3] = {-9999, -9999, -9999};
  int maxNodeId = nodesIDArray->GetRange()[1];

  char printStr[100];
  m_IntCharSize = sprintf(printStr,"%d",maxNodeId);

  fprintf(file,"*Node");
   
  sprintf(printStr,"\n\t%%%dd,\t %%21.13E,\t %%21.13E,\t %%21.13E",m_IntCharSize);

  for (int rowID = 0 ; rowID < rowsNumber ; rowID++)
  {
    float nodProgress = rowID / rowsNumber;
    m_ProgressHelper->UpdateProgressBar(nodProgress * 100);

    pointsToBeExported->GetPoint(rowID, pointCoordinates);
  
    fprintf(file,printStr, nodesIDArray->GetValue(rowID), pointCoordinates[0], pointCoordinates[1], pointCoordinates[2]);
  }

  m_CurrentProgress = rowsNumber;

  // clean up
  vtkDEL(inUGDeepCopy);
  vtkDEL(transform);
  vtkDEL(transformFilter);
  vtkDEL(syntheticNodesIDArray);

  nodesIDArray = NULL;

  return ALBA_OK;
}
//---------------------------------------------------------------------------
int albaOpExporterAbaqusFile::WriteElementsFile(FILE *file) 
{
  albaVMEMesh *input = albaVMEMesh::SafeDownCast(m_Input);
  assert(input);

  vtkUnstructuredGrid *inputUGrid = input->GetUnstructuredGridOutput()->GetUnstructuredGridData();

  // create elements matrix 
  int rowsNumber = inputUGrid->GetNumberOfCells();

  // read all the elements with their attribute data in memory (vnl_matrix)

  // get the ELEMENT_ID array
  vtkIntArray *elementIdArray = input->GetElementsIDArray();

  // get the Nodes Id array
  vtkIntArray *nodesIDArray = input->GetNodesIDArray();

  // get the TYPE array
  vtkIntArray *typeArray = input->GetElementsTypeArray();

  // get the REAL array
  vtkIntArray *realArray = input->GetElementsRealArray();

  ExportElement *exportVector = new ExportElement[rowsNumber];
	int rowID;
  
  for (rowID = 0 ; rowID < rowsNumber ; rowID++)
  {
    exportVector[rowID].elementID = elementIdArray ? elementIdArray->GetValue(rowID) : rowID+1;
    exportVector[rowID].matID = GetMatIdArray() ? GetMatIdArray()[rowID] : 1;
    exportVector[rowID].elementType = typeArray ? typeArray->GetValue(rowID) : 1;
    exportVector[rowID].elementReal = realArray ? realArray->GetValue(rowID) : 1;
    exportVector[rowID].cellID=rowID;

    // Create Elset
    if(m_MatIDMap.find(exportVector[rowID].matID) == m_MatIDMap.end())
    {
      ExportElset elset;
      elset.matID = exportVector[rowID].matID;
      elset.elementsIDVect.push_back(exportVector[rowID].elementID);
      m_Elsets.push_back(elset);

      m_MatIDMap[elset.matID]= m_Elsets.size()-1;
    }
    else
    {
      int elsetIndex = m_MatIDMap.find(exportVector[rowID].matID)->second;

      m_Elsets[elsetIndex].elementsIDVect.push_back(exportVector[rowID].elementID);
      m_Elsets[elsetIndex].matID = exportVector[rowID].matID;
    }
  }

  //qsort(exportVector, rowsNumber, sizeof(ExportElement), compareElem);
	int currCellNpoints = -1;


  // Write Elements
  char printStr[100];
  sprintf(printStr," %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd",m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize);

  char printStr2[10];
  sprintf(printStr2,"\t%%%dd",m_IntCharSize);

  for (rowID = 0 ; rowID < rowsNumber ; rowID++)
  {
    float elemProgress = (m_CurrentProgress + (float)rowID) / m_TotalElements;
    m_ProgressHelper->UpdateProgressBar(elemProgress * 100);

    vtkCell *currentCell = inputUGrid->GetCell(exportVector[rowID].cellID);
    vtkIdList *idList = currentCell->GetPointIds();
    int cellNpoints=currentCell->GetNumberOfPoints();

		if (currCellNpoints != cellNpoints)
		{
			fprintf(file, "\n*Element, type=C3D%d\n", cellNpoints);
			currCellNpoints = cellNpoints;
		}
		    
    fprintf(file,"\t%d, ", exportVector[rowID].elementID);
    
    for (int currentID = 0; currentID < cellNpoints; currentID++)
    {
      fprintf(file, printStr2, nodesIDArray->GetValue(idList->GetId(currentID)));

      if(currentID < cellNpoints-1)
        fprintf(file, ","); 
    }

    fprintf(file, "\n"); 
  }

  // Write Elsets

  for(int i=0; i< m_Elsets.size();i++)
  {
    fprintf(file,"*Elset, elset=Set_%d\n",(i+1));
    
    for (int j=0; j<m_Elsets[i].elementsIDVect.size(); j++)
    {
      fprintf(file,"%d", m_Elsets[i].elementsIDVect[j]);

     if(j<m_Elsets[i].elementsIDVect.size()-1)
        fprintf(file,", ", m_Elsets[i].elementsIDVect[j]);

	 if ((j != 0) && ((j+1) % 16) == 0)
		 fprintf(file, "\n");
    }

    fprintf(file,"\n*Solid Section, elset=Set_%d, material=Mat_%d\n",(i+1), m_Elsets[i].matID);
  }

  delete [] exportVector;

  return ALBA_OK;
}
//---------------------------------------------------------------------------
int albaOpExporterAbaqusFile::WriteMaterialsFile(FILE *file)
{
	// check this is a valid materials field data: I am assuming that vtk field data
	// contains only material attributes otherwise this code will not work
	vtkDataArray *materialsIDArray;
	vtkDataArray *exArray;
	vtkDataArray *nuxyArray;
	vtkDataArray *densArray;

	if (m_MaterialData)
	{
		// try field data
		materialsIDArray = m_MaterialData->GetArray("material_id");
		exArray = m_MaterialData->GetArray("EX");
		nuxyArray = m_MaterialData->GetArray("NUXY");
		densArray = m_MaterialData->GetArray("DENS");

		if (materialsIDArray && exArray && nuxyArray)
		{
			// get the number of materials
			int numberOfMaterials = materialsIDArray->GetNumberOfTuples();

			// write each material
			for (int i = 0; i < numberOfMaterials; i++)
			{
				int materialID = materialsIDArray->GetTuple1(i);

				fprintf(file, "*Material, name=Mat_%d\n", materialID);

				if (densArray && i < densArray->GetNumberOfTuples())
				{
					fprintf(file, "*Density\n");
					fprintf(file, "%.8lf,", densArray->GetTuple1(i));
					fprintf(file, "\n");
				}

				fprintf(file, "*Elastic\n");
				fprintf(file, "%.8lf, %.8lf", exArray->GetTuple1(i), nuxyArray->GetTuple1(i));
				fprintf(file, "\n");
			}

			m_CurrentProgress += numberOfMaterials;
		}
	}
	return ALBA_OK;
}
