/*=========================================================================

Program: ALBA
Module: albaOpExporterAnsysCDBFile.cpp
Authors: Nicola Vanella

Copyright (c) BIC
All rights reserved. See Copyright.txt or
http://www.scsitaly.com/Copyright.htm for details.

This software is distributed WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

#include "albaDefines.h" 
//----------------------------------------------------------------------------
// NOTE: Every CPP file in the ALBA must include "albaDefines.h" as first.
// This force to include Window,wxWidgets and VTK exactly in this order.
// Failing in doing this will result in a run-time error saying:
// "Failure#0: The value of ESP was not properly saved across a function call"
//----------------------------------------------------------------------------

#include "albaOpExporterAnsysCDBFile.h"

#include "albaDecl.h"
#include "albaGUI.h"

#include "albaSmartPointer.h"
#include "albaTagItem.h"
#include "albaTagArray.h"
#include "albaVME.h"
#include "albaVMEMesh.h"
#include "albaVMEMeshAnsysTextExporter.h"
#include "albaAbsMatrixPipe.h"
#include "albaProgressBarHelper.h"

#include <iostream>
#include <fstream>

// vtk includes
#include "vtkALBASmartPointer.h"
#include "vtkUnstructuredGrid.h"
#include "vtkCellArray.h"
#include "vtkDoubleArray.h"
#include "vtkIntArray.h"
#include "vtkPointData.h"
#include "vtkCellData.h"
#include "vtkFieldData.h"
#include "vtkTransform.h"
#include "vtkTransformFilter.h"

// vcl includes
#include <vcl_map.h>
#include <vcl_vector.h>

//----------------------------------------------------------------------------
albaCxxTypeMacro(albaOpExporterAnsysCDBFile);
//----------------------------------------------------------------------------

#define max(a,b)  (((a) > (b)) ? (a) : (b))

//----------------------------------------------------------------------------
albaOpExporterAnsysCDBFile::albaOpExporterAnsysCDBFile(const wxString &label) :
albaOpExporterAnsysCommon(label)
{

}
//----------------------------------------------------------------------------
albaOpExporterAnsysCDBFile::~albaOpExporterAnsysCDBFile()
{

}

//----------------------------------------------------------------------------
albaOp* albaOpExporterAnsysCDBFile::Copy()   
{
  albaOpExporterAnsysCDBFile *cp = new albaOpExporterAnsysCDBFile(m_Label);
  return cp;
}

//----------------------------------------------------------------------------
albaString albaOpExporterAnsysCDBFile::GetWildcard()
{
  return "cdb files (*.cdb)|*.cdb|All Files (*.*)|*.*";
}

//---------------------------------------------------------------------------
int albaOpExporterAnsysCDBFile::Write()
{
  FILE *outFile;
  outFile = fopen(m_AnsysOutputFileNameFullPath.ToAscii(), "w");

  albaVMEMesh *input = albaVMEMesh::SafeDownCast(m_Input);

  input->Update();
  input->GetUnstructuredGridOutput()->Update();
  input->GetUnstructuredGridOutput()->GetVTKData()->Update();

	m_ProgressHelper=new albaProgressBarHelper(m_Listener);
	m_ProgressHelper->SetTextMode(m_TestMode);
	m_ProgressHelper->InitProgressBar("Please wait exporting file...");

  // File header
  WriteHeaderFile(outFile);

  // Nodes
  // NBLOCK,6,SOLID,   2596567,    25
  // (3i8,6e20.13)
  // 209818       0       0-1.1025950600000E+02 1.7403367600000E+02-3.3185662800000E+02
	// ...
  // N,R5.3,LOC,       -1,
    
  WriteNodesFile(outFile);

  fprintf(outFile,"\n");

  // Elements
	//
	// ET,2,187
	//
  // EBLOCK,19,SOLID,   3436163,    234932
  //      1      2      1      1      0      0      0      0     10      0 148775  36953  18415  13487  17834 181600 144602 144605 177182
  // 177181 144601
	// ...
  //     -1

  WriteElementsFile(outFile);

  // Materials
  // MPTEMP,R5.0, 1, 1,  0.00000000    ,
  // MPDATA,R5.0, 1,EX  ,       1, 1,  26630.9000    ,
  // MPTEMP,R5.0, 1, 1,  0.00000000    ,
  // MPDATA,R5.0, 1,NUXY,       1, 1, 0.300000000    ,
  // MPTEMP,R5.0, 1, 1,  0.00000000    ,
  // MPDATA,R5.0, 1,DENS,       1, 1,  1.73281000    ,
 
  WriteMaterialsFile(outFile);

  // End file
  fprintf(outFile,"\n/GO\nFINISH\n");

  fclose(outFile);

  cppDEL(m_ProgressHelper);

  return ALBA_OK;
}

//---------------------------------------------------------------------------
int albaOpExporterAnsysCDBFile::WriteHeaderFile(FILE *file)
{
  time_t rawtime;
  struct tm * timeinfo;  time ( &rawtime );
  timeinfo = localtime ( &rawtime );
	
  fprintf(file, "!! Generated by albaOpExporterAnsysCDBFile %s\n", asctime (timeinfo)); 

  fprintf(file,"/PREP7\n");

  return ALBA_OK;
}
//---------------------------------------------------------------------------
int albaOpExporterAnsysCDBFile::WriteNodesFile(FILE *file)
{
  albaVMEMesh *input = albaVMEMesh::SafeDownCast(m_Input);
  assert(input);

  vtkUnstructuredGrid *inputUGrid = input->GetUnstructuredGridOutput()->GetUnstructuredGridData();

  vtkIntArray *nodesIDArray = albaVMEMesh::GetNodesIDArray(inputUGrid);

  vtkIntArray *syntheticNodesIDArray = NULL;

  if (nodesIDArray == NULL)
  {
    albaLogMessage("nodesID informations not found in vtk unstructured grid!\
                  Temporary nodes id array will be created in order to export the data.");

    int numPoints = inputUGrid->GetNumberOfPoints();
    syntheticNodesIDArray = vtkIntArray::New();

    int offset = 1 ;
    for (int i = 0; i < numPoints; i++) 
    {
      syntheticNodesIDArray->InsertNextValue(i + offset);
    }

    nodesIDArray = syntheticNodesIDArray;
  }

  assert(nodesIDArray != NULL);

  // get the pointsToBeExported
  int columnsNumber;
  int rowsNumber = inputUGrid->GetNumberOfPoints();
  columnsNumber = 4; // point ID + point coordinates

  vtkPoints *pointsToBeExported = NULL;

  vtkTransform *transform = NULL;
  vtkTransformFilter *transformFilter = NULL;
  vtkUnstructuredGrid *inUGDeepCopy = NULL;

  if (m_ABSMatrixFlag)
  {
    albaVMEMesh *inMesh = albaVMEMesh::SafeDownCast(m_Input);
    assert(inMesh);

    vtkMatrix4x4 *matrix = inMesh->GetAbsMatrixPipe()->GetMatrixPointer()->GetVTKMatrix();

    // apply abs matrix to geometry
    assert(matrix);

    transform = vtkTransform::New();
    transform->SetMatrix(matrix);

    transformFilter = vtkTransformFilter::New();
    inUGDeepCopy = vtkUnstructuredGrid::New();
    inUGDeepCopy->DeepCopy(inputUGrid);

    transformFilter->SetInput(inUGDeepCopy);
    transformFilter->SetTransform(transform);
    transformFilter->Update();

    pointsToBeExported = transformFilter->GetOutput()->GetPoints();
  } 
  else
  {
    // do not transform geometry
    pointsToBeExported = inputUGrid->GetPoints();
  }

  // read all the pointsToBeExported in memory (vnl_matrix)
  int pointIDColumn = 0;

  double pointCoordinates[3] = {-9999, -9999, -9999};

  int maxNodeId = nodesIDArray->GetRange()[1];
  int maxElemId = input->GetElementsIDArray()->GetRange()[1];

  char printStr[100];
  m_IntCharSize = sprintf(printStr,"%d", max(maxNodeId, maxElemId));
  
  fprintf(file,"NBLOCK,6,SOLID,   %d,    %d\n", maxNodeId, rowsNumber);
  fprintf(file,"(3i%d,6e22.13)\n",m_IntCharSize+1);
	 
  sprintf(printStr," %%%dd %%%dd %%%dd %%21.13E %%21.13E %%21.13E\n",m_IntCharSize,m_IntCharSize,m_IntCharSize);

  for (int rowID = 0 ; rowID < rowsNumber ; rowID++)
  {
    float nodProgress = rowID / m_TotalElements;
    m_ProgressHelper->UpdateProgressBar(nodProgress * 100);

    pointsToBeExported->GetPoint(rowID, pointCoordinates);
  
    fprintf(file,printStr, nodesIDArray->GetValue(rowID), 0 , 0, pointCoordinates[0], pointCoordinates[1], pointCoordinates[2]);
  }

  fprintf(file,"N,R5.3,LOC,       -1,\n");

  m_CurrentProgress = rowsNumber;

  // clean up
  vtkDEL(inUGDeepCopy);
  vtkDEL(transform);
  vtkDEL(transformFilter);
  vtkDEL(syntheticNodesIDArray);

  nodesIDArray = NULL;

  return ALBA_OK;
}
//---------------------------------------------------------------------------
int albaOpExporterAnsysCDBFile::WriteMaterialsFile(FILE *file)
{
	vtkFieldData *materialData = GetMaterialData();

	vtkDataArray *materialsIDArray = NULL;

  // try field data
  materialsIDArray = materialData->GetArray("material_id");

  if (materialsIDArray != NULL)
  {
		albaLogMessage("Found material array in field data");

    // get the number of materials
    int numberOfMaterials = materialsIDArray->GetNumberOfTuples();

    // get the number of materials properties
    int numberOfMaterialProperties = materialData->GetNumberOfArrays() - 1; // 1 is the materialsIDArray

    // gather material properties array names
    vcl_vector<wxString> materialProperties;
    for (int arrayID = 0; arrayID < materialData->GetNumberOfArrays(); arrayID++)
    {
      wxString arrayName = materialData->GetArray(arrayID)->GetName();
      if (arrayName != "material_id")
      {
        materialProperties.push_back(arrayName);
      }
    }

    fprintf(file,"\n");

    // For each material
    for (int i = 0; i < numberOfMaterials; i++)
    {
      float matProgress = (m_CurrentProgress + i) / m_TotalElements;
      m_ProgressHelper->UpdateProgressBar(matProgress * 100);

      int materialID = materialsIDArray->GetTuple(i)[0];

      // For each property
      for (int j = 0; j < numberOfMaterialProperties; j++)
      {
        wxString arrayName = materialProperties[j];
        vtkDataArray *array = materialData->GetArray(arrayName.ToAscii());

        fprintf(file,"MPTEMP,R5.0, 1, 1,  0.00000000    ,\n");
        fprintf(file,"MPDATA,R5.0, 1,%s,     %d, 1, %.8lf    ,",arrayName.ToAscii(), materialID, array->GetTuple(i)[0]);
        
        fprintf(file,"\n");
      }
    }  

    m_CurrentProgress += numberOfMaterials;
  }  

  return ALBA_OK;
}
//---------------------------------------------------------------------------
int albaOpExporterAnsysCDBFile::WriteElementsFile(FILE *file)
{
  albaVMEMesh *input = albaVMEMesh::SafeDownCast(m_Input);
  assert(input);

  vtkUnstructuredGrid *inputUGrid = input->GetUnstructuredGridOutput()->GetUnstructuredGridData();

  // create elements matrix 
  int rowsNumber = inputUGrid->GetNumberOfCells();

  // read all the elements with their attribute data in memory (vnl_matrix)

  ExportElement *exportVector = CreateExportElements(input, rowsNumber, inputUGrid, file);
  
  int maxElemId = input->GetElementsIDArray()->GetRange()[1];

  // Start EBlock
  fprintf(file,"\nEBLOCK,19,SOLID,   %d,    %d", maxElemId, rowsNumber);
  fprintf(file,"\n(19i%d)\n", m_IntCharSize + 1);
  
  int currentMatID = -1;
  int currentType = -1;
  int currentReal = 1;

  char printStr[100];
  sprintf(printStr," %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd %%%dd",m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize,m_IntCharSize);

  char printStr2[10];
  sprintf(printStr2," %%%dd",m_IntCharSize);

  for (int rowID = 0 ; rowID < rowsNumber ; rowID++)
  {
    float elemProgress = (m_CurrentProgress + (float)rowID) / m_TotalElements;
    m_ProgressHelper->UpdateProgressBar(elemProgress * 100);
    
    vtkCell *currentCell = inputUGrid->GetCell(exportVector[rowID].cellID);
    vtkIdList *idList = currentCell->GetPointIds();
    int cellNpoints=currentCell->GetNumberOfPoints();
     
    currentMatID = exportVector[rowID].matID;
    currentType = exportVector[rowID].elementType;

    fprintf(file, printStr, currentMatID, currentType, 1,  1,  0,  0,  0,  0, cellNpoints, 0, exportVector[rowID].elementID);
    
    for (int currentID = 0; currentID < cellNpoints; currentID++)
    {
      if(currentID == 8)  
        fprintf(file, "\n"); 

      fprintf(file, printStr2,  input->GetNodesIDArray()->GetValue(idList->GetId(currentID)));
    }

    fprintf(file, "\n"); 
  }

  // End EBlock
  fprintf(file,printStr2, -1);

  delete [] exportVector;

  return ALBA_OK;
}
